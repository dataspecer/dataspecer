generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:../database/database.db?connection_limit=1"
}

// Resource represents both package and model of various types.
model Resource {
  // Internal numerical ID for database purposes
  id Int @id @default(autoincrement())

  // Parent of the resource, if any.
  // If the resource is a root resource, this field is null.
  // Each model must have a parent, except for the roots.
  // List of children should be stored in the model itself, but for now, we will keep it here for simplicity.
  parentResourceId Int?

  // Public IRI of the resource.
  iri String @unique

  // Type of the resource that will be used to correctly determine how the resource should be handled.
  // It can be package, mounted package, conceptual model, EA file, etc.
  // This is only a type in context of this Prisma storage. In Github, or mounted packages, this types could be different.
  // We distinguish between types of representation and interpretation. This is the representation type.
  representationType String

  // Link to raw data of the resource.
  // There can be multiple data stores for the same resource.
  // You can consider them as individual files.
  // Most models will have only one file.
  // Default name is "model".
  dataStoreId String @default("{}")

  // User metadata that are common for all resources.
  // It could be a name, description, tags, etc.
  // This should be part of the model itself, but for now, we will keep it here for simplicity.
  userMetadata String @default("{}")

  // The URL of the linked Git repository
  // the given URL can either be the main page
  // (for example https://github.com/mff-uk/dataspecer)
  // or some of the branches
  // (for example https://github.com/mff-uk/dataspecer/tree/stable)
  // Should not end with "/"
  linkedGitRepositoryURL String @default("{}")

  // Note that it ends with ".". This is not oversight, "main." is invalid branch name
  // (the git branches can not end with "." (See https://stackoverflow.com/questions/3651860/which-characters-are-illegal-within-a-branch-name))
  // If the branch is set to "main." we consider it as the default branch.
  branch String @default("main.")

  // Is iri of the "git" project this package is part of.
  projectIri String @default("")
  // True if this package represents head of branch. That is, it should move with commits to this branch.
  // Otherwise it should not react to the webhooks from git, neither allow to commit from it to git.
  representsBranchHead Boolean @default(true)

  // Is the full hash of the last git commit on this package.
  // Note that this value is one commit ahead, when it comes commiting to git.
  // That is if we commit (or import package from git), it is pointing to the last commit on the relevant branch,
  // however if you also exported this value to the git, it would contain the parent commit hash, that is next-to-last commit.
  // It does not matter, since we don't commit the hash into Git (at least not yet), but it should be noted anyways.
  // Also note that if decided to export the hash, it has to work this way. It is simply not possible to compute commit hash
  // and then store it here and then commit, since the change of this value would change the computed commit hash.
  lastCommitHash String @default("")
  // If false then there exists commit in remote git repo, which failed to be pushed to DS through webhook, because of conflicts.
  isSynchronizedWithRemote Boolean @default(true)
  // When this is empty string, then it means the branch has currently no remaining merge commit.
  // If it is not empty, then it means there is another branch in DS, which finished mergeState, but
  // merge commit itself was not yet commited and pushed to Git repo.
  mergeFromHash String @default("")
  // We only need this for the commit message, otherwise it should be equivalent to using git merge with hash
  // Note that if this is empty, then it means that we merged directly from commit.
  // Also note that if the tip of branch moved, then the user should be probably warned, that he is performing merge directly from commit.
  // (which as said before only reflects in the default commit message).
  mergeFromBranch String @default("")

  // Technical metadata: creation date.
  createdAt DateTime @default(now())

  // Technical metadata: modification date.
  // It should be updated every time the iri, type, data stores or user metadata are changed.
  modifiedAt DateTime @default(now()) @updatedAt

  // Technical metadata: last time the subtree was modified.
  // It should represent the max time of all children.
  subtreeModifiedAt DateTime @default(now()) @updatedAt
}


model MergeState {
  // Internal numerical ID for database purposes
  id Int @id @default(autoincrement())

  uuid String @unique

  // Note: After thinking about it for some time, there are 3 possible situations when merge occurs
  //  1) Pulling - Here we have local branch, perform git pull (or rather git clone) and try to merge into our local branch
  //       - In this case we want to modify our local branch in such a way that eliminate all conflicts and can finally put in the remote changes
  //  2) Pushing - Here we have local branch with changes and perform git clone followed by git push
  //       - In this case we may get conflicts from the remote, if there were some new commits. So we want to once again modify our local branch by incorporating remote changes
  //       - So here it was reversed, that is we were merging from our local branch and into remote branch
  //  3) Manually choosing mergeFrom and mergeTo
  //       - Here both branches are local, however we would still like to modify only one. So here we choose that the mergeTo will be editable.
  // So what to take from this: We always want to modify our local DS branch and the remote to be unchanged
  //  - However local branch can be either mergeFrom or mergeTo. And that means that "mergeTo !== must be editable", which I thought is the case at first
  lastCommitHashMergeTo String @default("")
  rootFullPathToMetaMergeTo String @default("")
  rootIriMergeTo String @default("")
  // Only values from AvailableFilesystem are allowed (for now "ds-filesystem" and "classic-filesystem")
  filesystemTypeMergeTo String

  lastCommitHashMergeFrom String @default("")
  rootFullPathToMetaMergeFrom String @default("")
  rootIriMergeFrom String @default("")
  // Only values from AvailableFilesystem are allowed (for now "ds-filesystem" and "classic-filesystem")
  filesystemTypeMergeFrom String

  lastCommonCommitHash String @default("")

  // Can be either "mergeFrom" or "mergeTo"
  editable String
  // Can be one of these: "pull" | "push" | "merge"
  // Says the Cause of the merge. Combined with the "editable" field, that is the field which gives us information about what datasource we were changing,
  //  will give us the action, which should be performed after the resolving of all the conflicts.
  mergeStateCause String

  // Sometimes users may work in conceptual model editor for example, when merge state is active.
  // By work on resources they update the DiffTree in existing mergee states,
  // however recomputing DiffTree differences with each change is not really smart thing to do.
  // So each update in the relevant packages changes the isUpToDate field to false.
  // It is then the responsibility of server to provide (and store) recomputed DiffTree, when the merge state is queried.
  isUpToDate Boolean @default(true)
  conflictCount Int
  mergeStateData MergeStateData?
}

// This is separate table, since we want to sometimes only list the overview of the MergeState
// And we don't actually care about the data, that is the diffTree, conflicts, etc.
model MergeStateData {
  id Int @id @default(autoincrement())

  mergeStateId Int   @unique
  mergeState   MergeState  @relation(fields: [mergeStateId], references: [id], onDelete: Cascade)

  changedInEditable String @default("[]")
  removedInEditable String @default("[]")
  createdInEditable String @default("[]")
  // Conflicts are "static"
  conflicts String @default("[]")
  // Is subset of conflicts. Once it is empty we can safely merge.
  unresolvedConflicts String @default("[]")
  diffTree String @default("{}")
  diffTreeSize Int @default(0)
}


// These tables are preserved for migration purposes.

// Represents a data specification with additional metadata needed for the
// application to work.
model DataSpecification {
  // ID is a part of the final IRI of the data specification.
  id        String @id
  // Iri of the pim schema.
  pimSchema String @unique

  importsDataSpecifications     DataSpecification[] @relation("DataSpecificationReuse")
  isImportedByDataSpecification DataSpecification[] @relation("DataSpecificationReuse")

  // List of DataStructures that belongs to this specification
  dataStructures DataStructure[]

  // Assigns a store id for given PIM schema.
  // Currently every PIM and PSM schemas has its own store managed by the backand.
  storeId String @unique

  // Tags as means of categorization
  // JSON array of strings
  tags String @default("[]")

  // User defined data specification object
  // JSON serialized object
  artifactsConfiguration String @default("[]")

  cimAdapters String @default("[]")

  // Type of data specification.
  type String @default("http://dataspecer.com/vocabularies/data-specification/documentation")
}

// Data structure represents single Data PSM schema with its entities. It
// belongs to DataSpecification.
model DataStructure {
  id      String @id
  // Assigns a store id for the given PSM schema.
  // Currently every PIM and PSM schemas has its own store managed by the backand.
  storeId String

  psmSchema String @unique

  // List of artifacts that should be generated with from the schema.
  // Due to limitations of SQLite, we can't use array here, therefore the list
  // is a comma separated string.
  //artifacts String

  belongsToDataSpecification   DataSpecification? @relation(fields: [belongsToDataSpecificationId], references: [id])
  belongsToDataSpecificationId String?
}

model Package {
  // Internal Package Id
  id Int @id @default(autoincrement())

  // Parent Package Id, if any
  parentPackageId Int?

  // Chunk of puclic ID that is composed of parent package id and this package id...
  iriChunk String

  // Structured pakcage metadata
  metadata String @default("{}")

  @@unique([parentPackageId, iriChunk], name: "unique_chunk")
}

model system {
  key String @id
  value String
}
