import { z } from "zod";
import { asyncHandler } from "../utils/async-handler.ts";
import fs from "fs";
import express from "express";
import path from "path";
import os from "os";

/**
 * Generated by ChatGPT
 */
function wrapPrivateKey(keyData: string, type: "RSA" | "OPENSSH" = "OPENSSH"): string {
  // Normalize: remove whitespace/newlines
  const cleanKey = keyData.replace(/\s+/g, "");

  // Split into 64-character lines (PEM standard)
  const formattedKey = cleanKey.match(/.{1,64}/g)?.join("\n") ?? cleanKey;

  // Not ChatGPT - but I noticed that it has to end with empty line
  return `-----BEGIN ${type} PRIVATE KEY-----\n${formattedKey}\n-----END ${type} PRIVATE KEY-----\n`;
}

/**
 * We need this because the path inside ssh config file does not seem to correctly work for absolute paths,
 *  it either has to be relative, or C:/ has to be converted to /c/
 */
const relativizeAgainstSshInHomeDir = (givenPath: string): string => {
  const relativeAgainstSshInHomeDir = path.relative(path.join(os.homedir(), ".ssh"), givenPath);
  return convertToPosixPath(relativeAgainstSshInHomeDir);
};

const convertToPosixPath = (givenPath: string): string => {
  return givenPath.replace(/\\/g, "/");
};


const sshDirectoryForDS = path.resolve("./database/ds-users/.ssh");
const homeDirectorySshConfigPath = path.join(os.homedir(), ".ssh", "config");
export const sshForDSConfigPath = path.resolve(`${sshDirectoryForDS}/config`);
fs.rmSync(sshDirectoryForDS, { recursive: true, force: true });      // TODO RadStr: Not sure if we should remove it. However for debugging it is necessary.
const sshDSConfigPathRelativeToHomeDir = relativizeAgainstSshInHomeDir(sshForDSConfigPath);



export const storePrivateSSHKey = asyncHandler(async (request: express.Request, response: express.Response) => {
  const bodySchema = z.object({
    privateSSHKey: z.string().min(1),
  });

  const authenticatedUser = response.locals.session?.user;
  if (authenticatedUser === undefined) {
    response.sendStatus(401);
    return;
  }
  const userSSHIdentifer = createUserSSHIdentifier(authenticatedUser);

  const { privateSSHKey } = bodySchema.parse(request.body);

  storeNewPrivateSSHKeyToBackend(privateSSHKey, userSSHIdentifer);

  response.sendStatus(200);
  return;
});


export const createUserSSHIdentifier = (authenticatedUser: any | null | undefined): string | null => {
  if (authenticatedUser === null || authenticatedUser === undefined) {
    return null;
  }
  const userSSHIdentifer = `${authenticatedUser.accountProvider}-${authenticatedUser.providerAccountId}`;
  return userSSHIdentifer;
};

export function storeNewPrivateSSHKeyToBackend(privateSSHKey: string, userSSHIdentifer: string | null) {
  const fileContent = wrapPrivateKey(privateSSHKey);

  fs.mkdirSync(sshDirectoryForDS, { recursive: true });

  const privateSSHKeyFilePath = convertToPosixPath(path.normalize(`${sshDirectoryForDS}/private-ssh-key-${userSSHIdentifer}`));
  fs.writeFileSync(privateSSHKeyFilePath, fileContent);
  fs.chmodSync(privateSSHKeyFilePath, 0o600);

  // Hardcoded for github
  const configIdentifier = `Host ${userSSHIdentifer}`;
  const identityFileLine = `    IdentityFile ${privateSSHKeyFilePath}`;
  const newConfigEntry = `${configIdentifier}
    HostName github.com
    User git
${identityFileLine}\n\n`;

  if (!replaceSSHConfigEntry(sshForDSConfigPath, configIdentifier, identityFileLine)) {
    fs.appendFileSync(sshForDSConfigPath, newConfigEntry);     // It was not present, just append it
  }

  // Include our config into the config in home directory
  const theIncludesStringForConfig = `Include ${sshDSConfigPathRelativeToHomeDir}`;
  if (!fs.existsSync(homeDirectorySshConfigPath)) {
    const sshDir = path.dirname(homeDirectorySshConfigPath);
    fs.mkdirSync(sshDir, { recursive: true }); // Ensures all needed dirs exist (needed for the docker)
    fs.writeFileSync(homeDirectorySshConfigPath, theIncludesStringForConfig);
  }
  else {
    if (!fs.readFileSync(homeDirectorySshConfigPath).includes(theIncludesStringForConfig)) {
      fs.appendFileSync(homeDirectorySshConfigPath, `\n${theIncludesStringForConfig}`);
    }
  }
}


/**
 * Generated with ChatGPT's help
 * Replaces the entry if it was present.
 * @returns True if the entry was present, false if it was not.
 */
function replaceSSHConfigEntry(filePath: string, matchLineToReplace: string, identityFileLine: string): boolean {
  // Read file into array of lines
  let lines: string[];
  try {
    lines = fs.readFileSync(filePath, "utf-8").split(/\r?\n/);
  }
  catch (error) {
    return false;
  }

  // Find the index of the matching line
  const index = lines.findIndex(line => line.includes(matchLineToReplace));

  if (index === -1) {
    return false;
  }

  // Replace the path
  lines[index + 3] = identityFileLine;

  // Write back to file
  fs.writeFileSync(filePath, lines.join("\n"), "utf-8");

  return true;
}
