// TODO RadStr: Move the content of this file into package probably

import express from "express"
import _ from "lodash";
import { AccessToken, AccessTokenType, CommitterInfo } from "@dataspecer/git";
import { SimpleGit } from "simple-git";
import fs from "fs";
import path from "path";


// TODO RadStr: Change to Dataspecer after debugging stage
export const GITHUB_USER_AGENT = "Dataspecer-test";



/**
 *
 * @param remoteRepoURLDomain is the domain part of URL without www., that is for example gitlab.com or github.com
 * @param userName is the name of the person pushing/committing or doing anything with the URL
 * @param givenRepositoryUserName is the user under which the repository is created, that is the ending part of the url, that is for example github.com/{givenRepositoryUserName}/{repoName}
 * @param repoName is the name of the repository to be used in the URL
 * @param accessToken is access token - Either from OAuth or PAT
 * @returns
 */
export const createRepoURLWithAuthorizationFromData = (remoteRepoURLDomain: string, userName: string, givenRepositoryUserName: string, repoName: string, accessToken: string) => {
  return `https://${userName}:${accessToken}@${remoteRepoURLDomain}/${givenRepositoryUserName}/${repoName}`;
};

/**
 * @param userName is the name of the person pushing/committing or doing anything with the URL
 * @param givenRepositoryUserName is the user under which the repository is created, that is the ending part of the url, that is for example github.com/{givenRepositoryUserName}/{repoName}
 */
const getHttpsRepoURLWithAuthorization = (remoteRepoURL: string, userName: string, givenRepositoryUserName: string, repoName: string, accessToken: string): string => {
  const remoteRepoURLDomain = extractPartOfRepositoryURL(remoteRepoURL, "url-domain") ?? "github.com";
  return createRepoURLWithAuthorizationFromData(remoteRepoURLDomain, userName, givenRepositoryUserName, repoName, accessToken);
};


export function getAuthorizationURL(
  committerInfo: CommitterInfo,
  accessToken: AccessToken,
  remoteRepositoryURL: string,
  repositoryUserName: string,
  repositoryName: string,
): string {
  let repoURLWithAuthorization: string;
  if (accessToken.type === AccessTokenType.SSH) {
    repoURLWithAuthorization = `git@${accessToken.value}:${repositoryUserName}/${repositoryName}.git`;
  }
  else if (accessToken.type === AccessTokenType.PAT) {
    repoURLWithAuthorization = getHttpsRepoURLWithAuthorization(remoteRepositoryURL, committerInfo.name, repositoryUserName, repositoryName, accessToken.value);
  }
  else {
    throw new Error(`Unknown access token type: ${accessToken.type}`);
  }

  return repoURLWithAuthorization;
}

export function createUniqueCommitMessage(): string {
  return "Autogenerated commit message " + Date.now();
}

/**
 * If the given {@link commitMessage} is of length 0, then it is transformed to null.
 * Otherwise the {@link commitMessage} is returned
 */
export function transformCommitMessageIfEmpty(commitMessage: string): string | null {
  const transformedCommitMessage = commitMessage.length === 0 ? null : commitMessage;
  return transformedCommitMessage;
}


// TODO RadStr: Not really git util
export function createURLFromExpressRequest(request: express.Request): string {
  return `${request.protocol}://${request.get("host")}${request.originalUrl}`;
}

export function convertExpressRequestToNormalRequest(url: string, request: express.Request) {
  const convertedRequest  = new Request(url, {
    method: request.method,
    headers: request.headers as Record<string, string>,
    // body: req.method !== "GET" && req.method !== "HEAD" ? req : undefined,
  });

  return convertedRequest;
}

// TODO RadStr: Once again not exactly git util
/**
 * Note that we also use this on paths on filesystem for {@link ClassicFilesystem}.
 * This is for simplicity and uniformity, even though we should ideally use "\\" on Windows (that is path.sep).
 * But it really complicates stuff since we then have to spend extra mental capacity on thinking whether given can use OS specific separators or it is IRI.
 * @returns Given {@link pathParts} joined by "/".
 */
export function dsPathJoin(...pathParts: string[]) {
  return pathParts.filter(pathPart => pathPart !== "").join("/");
}

// TODO: Maybe put into different utils file
/**
 * @param repositoryURL is the URL of the repository
 * @returns The part of given URL. Where the given URL can either be the main page
 *  (for example https://github.com/mff-uk/dataspecer) or some of the branches (for example https://github.com/mff-uk/dataspecer/tree/stable).
 *  Should also work for gitlab or any other git providers following similar URL structure.
 *  In the example mff-uk is "user-name" and dataspecer is "repository-name".
 *  For "branch" returns null, if it not explicitly provided in the {@link repositoryURL}.
 */
export function extractPartOfRepositoryURL(repositoryURL: string, part: "url-domain" | "repository-name" | "user-name"): string | null {
  try {
    const parsedUrl = new URL(repositoryURL);

    if (part === "url-domain") {
      return parsedUrl.host;
    }

    // TODO: Not checking if the repository URL is correct
    const pathParts = parsedUrl.pathname.split("/").filter(part => part.length > 0);

    if (pathParts.length < 2) {
      return null;
    }

    // Where pathParts = ["mff-uk", "dataspecer", "tree", "stable"] for the above example
    if (part === "repository-name") {
      return pathParts[1];
    }
    else if (part === "user-name") {
      return pathParts[0];
    }
    else if (part === "branch") {
      // TODO RadStr: In this case it is provider specific
      if (pathParts.length < 4 || pathParts.at(-2) !== "tree") {
        return null;
      }

      return pathParts.at(-1)!;
    }

    return null;
  } catch (error) {
    return null;
  }
}


/**
 * Based on ChatGPT - it removes every "K" property from the type recursively
 */
type DeepOmit<T, K extends PropertyKey> = {
  [P in keyof T as P extends K ? never : P]:
    T[P] extends object ? DeepOmit<T[P], K> : T[P];
};

/**
 * Also ChatGPT
 * @deprecated No longer used, but it may be useful in future, so I keep it here
 */
export function deepOmit<T extends object>(obj: T, keyToRemove: string): any {
  if (Array.isArray(obj)) {
    return obj.map(item => deepOmit(item, keyToRemove));
  } else if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj)
        .filter(([k]) => k !== keyToRemove)
        .map(([k, v]) => [k, deepOmit(v, keyToRemove)])
    );
  }
  return obj;
}


/**
 * @returns true if the given value equals true ... for some reason zod does not like booleans so we do it explictly
 */
export function stringToBoolean(value: string): boolean {
  return value.toLowerCase() === "true";
}

export function getBaseUrl(request: express.Request) {
  const baseURL = request.protocol + '://' + request.get("host");
  return baseURL;
}

export async function getLastCommitHash(git: SimpleGit) {
  const gitLastCommitHash = await git.revparse(["HEAD"]);
  return gitLastCommitHash;
}

export async function getLastCommit(git: SimpleGit) {
  return (await git.log({ maxCount: 1 })).latest;
}

/**
 * Removes everything inside the {@link rootDirectory} in filesystem, except the given {@link exceptions}. The exceptions should be the name of entries to skip inside the dir.
 */
export function removeEverythingExcept(rootDirectory: string, exceptions: string[]) {
  const directoryEntries = fs.readdirSync(rootDirectory);

  for (const entry of directoryEntries) {
    if (exceptions.includes(entry)) {
      continue;
    }

    const fullPath = path.join(rootDirectory, entry);
    removePathRecursively(fullPath);
  }
}

/**
 * Just calls fs.rmSync(path, { recursive: true, force: true }); to remove everything on path and further
 */
export function removePathRecursively(path: string) {
  fs.rmSync(path, { recursive: true, force: true });
}

/**
 * @param gitLink is used only to provide the correct error message
 * @throws Throws error if {@link repoName} or {@link userName} are null
 */
export function checkErrorBoundaryForCommitAction(
  gitLink: string,
  repoName: string | null,
  userName: string | null,
): repoName is NonNullable<string> {
  if (repoName === null) {
    throw new Error(`Repository name could not be extracted from the repository URL: ${gitLink}`);
  }
  if (userName === null) {
    throw new Error(`User name could not be extracted from the repository URL: ${gitLink}`);
  }

  return true;
}