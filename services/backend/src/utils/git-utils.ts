// TODO RadStr: Move the content of this file into package probably

import express from "express"
import _ from "lodash";
import { AccessToken, AccessTokenType, CommitterInfo } from "@dataspecer/git";
import { SimpleGit } from "simple-git";
import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { homedir } from "os";
import { join } from "path";


// TODO RadStr: Change to Dataspecer after debugging stage
export const GITHUB_USER_AGENT = "Dataspecer-test";



/**
 *
 * @param remoteRepoURLDomain is the domain part of URL without www., that is for example gitlab.com or github.com
 * @param userName is the name of the person pushing/committing or doing anything with the URL
 * @param givenRepositoryUserName is the user under which the repository is created, that is the ending part of the url, that is for example github.com/{givenRepositoryUserName}/{repoName}
 * @param repoName is the name of the repository to be used in the URL
 * @param accessToken is access token - Either from OAuth or PAT
 * @returns
 */
export const createRepoURLWithAuthorizationFromData = (remoteRepoURLDomain: string, userName: string, givenRepositoryUserName: string, repoName: string, accessToken: string) => {
  return `https://${userName}:${accessToken}@${remoteRepoURLDomain}/${givenRepositoryUserName}/${repoName}`;
};

/**
 * @param userName is the name of the person pushing/committing or doing anything with the URL
 * @param givenRepositoryUserName is the user under which the repository is created, that is the ending part of the url, that is for example github.com/{givenRepositoryUserName}/{repoName}
 */
const getHttpsRepoURLWithAuthorization = (remoteRepoURL: string, userName: string, givenRepositoryUserName: string, repoName: string, accessToken: string): string => {
  const remoteRepoURLDomain = extractPartOfRepositoryURL(remoteRepoURL, "url-domain") ?? "github.com";
  return createRepoURLWithAuthorizationFromData(remoteRepoURLDomain, userName, givenRepositoryUserName, repoName, accessToken);
};


export function getAuthorizationURL(
  committerInfo: CommitterInfo,
  accessToken: AccessToken,
  remoteRepositoryURL: string,
  repositoryUserName: string,
  repositoryName: string,
): string {
  let repoURLWithAuthorization: string;
  if (accessToken.type === AccessTokenType.SSH) {
    repoURLWithAuthorization = `git@${accessToken.value}:${repositoryUserName}/${repositoryName}.git`;
  }
  else if (accessToken.type === AccessTokenType.PAT) {
    repoURLWithAuthorization = getHttpsRepoURLWithAuthorization(remoteRepositoryURL, committerInfo.name, repositoryUserName, repositoryName, accessToken.value);
  }
  else {
    throw new Error(`Unknown access token type: ${accessToken.type}`);
  }

  return repoURLWithAuthorization;
}

export function createUniqueCommitMessage(): string {
  return "Autogenerated commit message " + Date.now();
}

/**
 * If the given {@link commitMessage} is of length 0, then it is transformed to null.
 * Otherwise the {@link commitMessage} is returned
 */
export function transformCommitMessageIfEmpty(commitMessage: string): string | null {
  const transformedCommitMessage = commitMessage.length === 0 ? null : commitMessage;
  return transformedCommitMessage;
}


// TODO RadStr: Not really git util
export function createURLFromExpressRequest(request: express.Request): string {
  return `${request.protocol}://${request.get("host")}${request.originalUrl}`;
}

export function convertExpressRequestToNormalRequest(url: string, request: express.Request) {
  const convertedRequest  = new Request(url, {
    method: request.method,
    headers: request.headers as Record<string, string>,
    // body: req.method !== "GET" && req.method !== "HEAD" ? req : undefined,
  });

  return convertedRequest;
}

// TODO RadStr: Once again not exactly git util
/**
 * Note that we also use this on paths on filesystem for {@link ClassicFilesystem}.
 * This is for simplicity and uniformity, even though we should ideally use "\\" on Windows (that is path.sep).
 * But it really complicates stuff since we then have to spend extra mental capacity on thinking whether given can use OS specific separators or it is IRI.
 * @returns Given {@link pathParts} joined by "/".
 */
export function dsPathJoin(...pathParts: string[]) {
  return pathParts.filter(pathPart => pathPart !== "").join("/");
}

// TODO: Maybe put into different utils file
/**
 * @param repositoryURL is the URL of the repository
 * @returns The part of given URL. Where the given URL can either be the main page
 *  (for example https://github.com/mff-uk/dataspecer) or some of the branches (for example https://github.com/mff-uk/dataspecer/tree/stable).
 *  Should also work for gitlab or any other git providers following similar URL structure.
 *  In the example mff-uk is "user-name" and dataspecer is "repository-name".
 *  For "branch" returns null, if it not explicitly provided in the {@link repositoryURL}.
 */
export function extractPartOfRepositoryURL(repositoryURL: string, part: "url-domain" | "repository-name" | "user-name"): string | null {
  try {
    const parsedUrl = new URL(repositoryURL);

    if (part === "url-domain") {
      return parsedUrl.host;
    }

    // TODO: Not checking if the repository URL is correct
    const pathParts = parsedUrl.pathname.split("/").filter(part => part.length > 0);

    if (pathParts.length < 2) {
      return null;
    }

    // Where pathParts = ["mff-uk", "dataspecer", "tree", "stable"] for the above example
    if (part === "repository-name") {
      return pathParts[1];
    }
    else if (part === "user-name") {
      return pathParts[0];
    }
    else if (part === "branch") {
      // TODO RadStr: In this case it is provider specific
      if (pathParts.length < 4 || pathParts.at(-2) !== "tree") {
        return null;
      }

      return pathParts.at(-1)!;
    }

    return null;
  } catch (error) {
    return null;
  }
}


/**
 * Based on ChatGPT - it removes every "K" property from the type recursively
 */
type DeepOmit<T, K extends PropertyKey> = {
  [P in keyof T as P extends K ? never : P]:
    T[P] extends object ? DeepOmit<T[P], K> : T[P];
};

/**
 * Also ChatGPT
 * @deprecated No longer used, but it may be useful in future, so I keep it here
 */
export function deepOmit<T extends object>(obj: T, keyToRemove: string): any {
  if (Array.isArray(obj)) {
    return obj.map(item => deepOmit(item, keyToRemove));
  } else if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj)
        .filter(([k]) => k !== keyToRemove)
        .map(([k, v]) => [k, deepOmit(v, keyToRemove)])
    );
  }
  return obj;
}


/**
 * @returns true if the given value equals true ... for some reason zod does not like booleans so we do it explictly
 */
export function stringToBoolean(value: string): boolean {
  return value.toLowerCase() === "true";
}

/**
 * @returns Returns the part of url containing protocol, host and possible the "/api" if it is the route for backend (for example in case of docker).
 */
export function getBaseBackendUrl(request: express.Request) {
  const possibleApiRoute = request.originalUrl.split("/")[1];
  let baseUrlSuffix = "";
  if (possibleApiRoute === "api") {
    baseUrlSuffix = "/api";
  }
  const baseURL = request.protocol + '://' + request.get("host") + baseUrlSuffix;
  return baseURL;
}

export async function getLastCommitHash(git: SimpleGit) {
  const gitLastCommitHash = await git.revparse(["HEAD"]);
  return gitLastCommitHash;
}

export async function getLastCommit(git: SimpleGit) {
  return (await git.log({ maxCount: 1 })).latest;
}

/**
 * Removes everything inside the {@link rootDirectory} in filesystem, except the given {@link exceptions}. The exceptions should be the name of entries to skip inside the dir.
 */
export function removeEverythingExcept(rootDirectory: string, exceptions: string[]) {
  const directoryEntries = fs.readdirSync(rootDirectory);

  for (const entry of directoryEntries) {
    if (exceptions.includes(entry)) {
      continue;
    }

    const fullPath = path.join(rootDirectory, entry);
    removePathRecursively(fullPath);
  }
}

/**
 * Just calls fs.rmSync(path, { recursive: true, force: true }); to remove everything on path and further
 */
export function removePathRecursively(path: string) {
  fs.rmSync(path, { recursive: true, force: true });
}

/**
 * @param gitLink is used only to provide the correct error message
 * @throws Throws error if {@link repoName} or {@link userName} are null
 */
export function checkErrorBoundaryForCommitAction(
  gitLink: string,
  repoName: string | null,
  userName: string | null,
): repoName is NonNullable<string> {
  if (repoName === null) {
    throw new Error(`Repository name could not be extracted from the repository URL: ${gitLink}`);
  }
  if (userName === null) {
    throw new Error(`User name could not be extracted from the repository URL: ${gitLink}`);
  }

  return true;
}


/**
 * The reason for existence of this method lies in the fact that user (this is always the case when running in docker), may have not defined the
 * github as known host. Therefore the action of committing would need confirmation, which can not provide if running from application, so we fail with error.
 */
export function populateSshKnownHosts() {
  addGitHubHostKeyToSshKnownHosts();
}

/**
 * Generated by ChatGPT
 */
function addGitHubHostKeyToSshKnownHosts() {
  const sshDir = join(homedir(), ".ssh");
  const knownHosts = join(sshDir, "known_hosts");

  // Ensure ~/.ssh exists
  if (!fs.existsSync(sshDir)) {
    fs.mkdirSync(sshDir, { mode: 0o700 });
  }

  exec("ssh-keyscan -t ed25519 github.com", (error, stdout) => {
    let existingContent = "";
    let knownHostsExist: boolean;
    if (fs.existsSync(knownHosts)) {
      existingContent = fs.readFileSync(knownHosts, "utf8");
      knownHostsExist = true;
    }
    else {
      knownHostsExist = false;
    }

    // Check if ANY line in known_hosts is for "github.com"
    const hasGitHubEntry = existingContent
      .split("\n")
      .some(line => line.startsWith("github.com ssh-ed25519 "));

    if (error) {
      if (error.code === 1) {
        // We are most-likely on windows and windows usually has some weird implementation of ssh, which does not suppory the ssh-keyscan (unsupported KEX method)
        if (!hasGitHubEntry) {
          // https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
          const gitHubKnownHostsExtension = `github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=`
          fs.appendFileSync(knownHosts, gitHubKnownHostsExtension);
          if (!knownHostsExist) {
            fs.chmodSync(knownHosts, 0o644);
          }
        }
      }
      else {
        // TODO RadStr: Debug print
        console.error("ssh-keyscan failed:", error);
      }
      return;
    }

    if (!hasGitHubEntry) {
      fs.appendFileSync(knownHosts, stdout);
      if (!knownHostsExist) {
        fs.chmodSync(knownHosts, 0o644);
      }
    }
  });
}

/**
 * When working with auth, we are checking if the urls match certain values. For that we need to strip the /api away in cases when it is present.
 * For example when running in Docker. When it is not present we returned the {@link url} unchanged (for example when running locally with locahost:3100)
 */
export function stripApiPrefixFromUrl(url: string): string {
  if (url.startsWith("/api")) {
    return url.substring(4);
  }
  return url;
}