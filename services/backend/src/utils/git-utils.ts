// TODO RadStr: Move the content of this file into package probably

import express from "express"
import _ from "lodash";
import { AccessToken, AccessTokenType, CommitterInfo } from "@dataspecer/git";
import { getHttpsRepoURLWithAuthorization } from "../git-never-commit.ts";
import { SimpleGit } from "simple-git";
import fs from "fs";
import path from "path";


// TODO RadStr: Change to Dataspecer after debugging stage
export const GITHUB_USER_AGENT = "Dataspecer-test";

export function getAuthorizationURL(
  committerInfo: CommitterInfo,
  accessToken: AccessToken,
  remoteRepositoryURL: string,
  repositoryUserName: string,
  repositoryName: string,
): string {
  let repoURLWithAuthorization: string;
  if (accessToken.type === AccessTokenType.SSH) {
    repoURLWithAuthorization = `git@${accessToken.value}:${repositoryUserName}/${repositoryName}.git`;
  }
  else if (accessToken.type === AccessTokenType.PAT) {
    repoURLWithAuthorization = getHttpsRepoURLWithAuthorization(remoteRepositoryURL, committerInfo.name, repositoryUserName, repositoryName, accessToken.value);
  }
  else {
    throw new Error(`Unknown access token type: ${accessToken.type}`);
  }

  return repoURLWithAuthorization;
}

export function createUniqueCommitMessage(): string {
  return "Autogenerated commit message " + Date.now();
}

/**
 * If the given {@link commitMessage} is of length 0, then it is transformed to null.
 * Otherwise the {@link commitMessage} is returned
 */
export function transformCommitMessageIfEmpty(commitMessage: string): string | null {
  const transformedCommitMessage = commitMessage.length === 0 ? null : commitMessage;
  return transformedCommitMessage;
}


// TODO RadStr: Not really git util
export function createURLFromExpressRequest(request: express.Request): string {
  return `${request.protocol}://${request.get("host")}${request.originalUrl}`;
}

export function convertExpressRequestToNormalRequest(url: string, request: express.Request) {
  const convertedRequest  = new Request(url, {
    method: request.method,
    headers: request.headers as Record<string, string>,
    // body: req.method !== "GET" && req.method !== "HEAD" ? req : undefined,
  });

  return convertedRequest;
}

// TODO RadStr: Once again not exactly git util
/**
 * Note that we also use this on paths on filesystem for {@link ClassicFilesystem}.
 * This is for simplicity and uniformity, even though we should ideally use "\\" on Windows (that is path.sep).
 * But it really complicates stuff since we then have to spend extra mental capacity on thinking whether given can use OS specific separators or it is IRI.
 * @returns Given {@link pathParts} joined by "/".
 */
export function dsPathJoin(...pathParts: string[]) {
  return pathParts.join("/");
}

// TODO: Maybe put into different utils file
/**
 * @param repositoryURL is the URL of the repository
 * @returns The part of given URL. Where the given URL can either be the main page
 *  (for example https://github.com/mff-uk/dataspecer) or some of the branches (for example https://github.com/mff-uk/dataspecer/tree/stable).
 *  Should also work for gitlab or any other git providers following similar URL structure.
 *  In the example mff-uk is "user-name" and dataspecer is "repository-name".
 *  For "branch" returns null, if it not explicitly provided in the {@link repositoryURL}.
 */
export function extractPartOfRepositoryURL(repositoryURL: string, part: "url-domain" | "repository-name" | "user-name"): string | null {
  try {
    const parsedUrl = new URL(repositoryURL);

    if (part === "url-domain") {
      return parsedUrl.host;
    }

    // TODO: Not checking if the repository URL is correct
    const pathParts = parsedUrl.pathname.split("/").filter(part => part.length > 0);

    if (pathParts.length < 2) {
      return null;
    }

    // Where pathParts = ["mff-uk", "dataspecer", "tree", "stable"] for the above example
    if (part === "repository-name") {
      return pathParts[1];
    }
    else if (part === "user-name") {
      return pathParts[0];
    }
    else if (part === "branch") {
      // TODO RadStr: In this case it is provider specific
      if (pathParts.length < 4 || pathParts.at(-2) !== "tree") {
        return null;
      }

      return pathParts.at(-1)!;
    }

    return null;
  } catch (error) {
    return null;
  }
}


/**
 * Based on ChatGPT - it removes every "K" property from the type recursively
 */
type DeepOmit<T, K extends PropertyKey> = {
  [P in keyof T as P extends K ? never : P]:
    T[P] extends object ? DeepOmit<T[P], K> : T[P];
};

/**
 * Also ChatGPT
 * @deprecated No longer used, but it may be useful in future, so I keep it here
 */
export function deepOmit<T extends object>(obj: T, keyToRemove: string): any {
  if (Array.isArray(obj)) {
    return obj.map(item => deepOmit(item, keyToRemove));
  } else if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj)
        .filter(([k]) => k !== keyToRemove)
        .map(([k, v]) => [k, deepOmit(v, keyToRemove)])
    );
  }
  return obj;
}


/**
 * @returns true if the given value equals true ... for some reason zod does not like booleans so we do it explictly
 */
export function stringToBoolean(value: string): boolean {
  return value.toLowerCase() === "true";
}

export function getBaseUrl(request: express.Request) {
  const baseURL = request.protocol + '://' + request.get("host");
  return baseURL;
}

export async function getLastCommitHash(git: SimpleGit) {
  const gitLastCommitHash = await git.revparse(["HEAD"]);
  return gitLastCommitHash;
}

export function removeEverythingExcept(rootDirectory: string, exceptions: string[]) {
  const directoryEntries = fs.readdirSync(rootDirectory);

  for (const entry of directoryEntries) {
    if (exceptions.includes(entry)) {
      continue;
    }

    const fullPath = path.join(rootDirectory, entry);
    fs.rmSync(fullPath, { recursive: true, force: true });
  }
}