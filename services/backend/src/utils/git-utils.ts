// TODO RadStr: Move the content of this file into package probably

import express from "express"
import YAML from "yaml";
import { DatastoreComparison, DiffTree, ResourceComparison, ResourceComparisonResult } from "../models/merge-state-model.ts";
import { getDatastoreInfoOfGivenDatastoreType } from "../export-import/filesystem-abstractions/implementations/ds-filesystem.ts";
import _ from "lodash";
import { ComparisonData } from "../routes/git-webhook-handler.ts";
import { DatastoreInfo, DirectoryNode, FileNode, FilesystemNode, FilesystemAbstraction } from "@dataspecer/git";



// TODO RadStr: Change to Dataspecer after debugging stage
export const GITHUB_USER_AGENT = "Dataspecer-test";



export function createUniqueCommitMessage(): string {
  return "Autogenerated commit message" + Date.now();
}

/**
 * If the given {@link commitMessage} is of length 0, then it is transformed to null.
 * Otherwise the {@link commitMessage} is returned
 */
export function transformCommitMessageIfEmpty(commitMessage: string): string | null {
  const transformedCommitMessage = commitMessage.length === 0 ? null : commitMessage;
  return transformedCommitMessage;
}


// TODO RadStr: Not really git util
export function createURLFromExpressRequest(request: express.Request): string {
  return `${request.protocol}://${request.get("host")}${request.originalUrl}`;
}

export function convertExpressRequestToNormalRequest(url: string, request: express.Request) {
  const convertedRequest  = new Request(url, {
    method: request.method,
    headers: request.headers as Record<string, string>,
    // body: req.method !== "GET" && req.method !== "HEAD" ? req : undefined,
  });

  return convertedRequest;
}

// TODO RadStr: Once again not exactly git util
/**
 * Note that we also use this on paths on filesystem for {@link ClassicFilesystem}.
 * This is for simplicity and uniformity, even though we should ideally use "\\" on Windows (that is path.sep).
 * But it really complicates stuff since we then have to spend extra mental capacity on thinking whether given can use OS specific separators or it is IRI.
 * @returns Given {@link pathParts} joined by "/".
 */
export function dsPathJoin(...pathParts: string[]) {
  return pathParts.join("/");
}


// TODO RadStr: Once again maybe not git-utils
/**
 * Inverse to {@link stringifyDatastoreBasedOnFormat}
 * @param shouldConvert if false then returns the given {@link datastoreContent} without performing any converting action.
 * @returns Returns {@link datastoreContent} in format of string to the format in which is the string content (that is what we got from the name extension, for example .json).
 */
export function convertDatastoreBasedOnFormat(datastoreContent: string, format: string | null, shouldConvert: boolean): any {
  if (!shouldConvert) {
    return datastoreContent;
  }

  if (format === "json") {
    return JSON.parse(datastoreContent);
  }
  else if (format === "yaml") {
    return YAML.parse(datastoreContent);
  }

  return datastoreContent;
}


// TODO RadStr: Once again maybe not git-utils
/**
 * Inverse to {@link convertDatastoreBasedOnFormat}
 * @returns Stringified {@link datastoreContent}, which was on input in given {@link foramt}. If {@link shouldConvert}, then just returns the {@link datastoreContent}.
 */
export function stringifyDatastoreBasedOnFormat(datastoreContent: any, format: string | null, shouldConvert: boolean): string {
  if (!shouldConvert) {
    return datastoreContent;
  }

  const indent = 2;

  if (format === "json") {
    return JSON.stringify(datastoreContent, null, indent);
  }
  else if (format === "yaml") {
    return YAML.stringify(datastoreContent, { indent });
  }

  return datastoreContent;
}
// TODO: Maybe put into different utils file
/**
 * @param repositoryURL is the URL of the repository
 * @returns The part of given URL. Where the given URL can either be the main page
 *  (for example https://github.com/mff-uk/dataspecer) or some of the branches (for example https://github.com/mff-uk/dataspecer/tree/stable).
 *  Should also work for gitlab or any other git providers following similar URL structure.
 *  In the example mff-uk is "user-name" and dataspecer is "repository-name".
 *  For "branch" returns null, if it not explicitly provided in the {@link repositoryURL}.
 */
export function extractPartOfRepositoryURL(repositoryURL: string, part: "url-domain" | "repository-name" | "user-name"): string | null {
  try {
    const parsedUrl = new URL(repositoryURL);

    if (part === "url-domain") {
      return parsedUrl.host;
    }

    // TODO: Not checking if the repository URL is correct
    const pathParts = parsedUrl.pathname.split("/").filter(part => part.length > 0);

    if (pathParts.length < 2) {
      return null;
    }

    // Where pathParts = ["mff-uk", "dataspecer", "tree", "stable"] for the above example
    if (part === "repository-name") {
      return pathParts[1];
    }
    else if (part === "user-name") {
      return pathParts[0];
    }
    else if (part === "branch") {
      // TODO RadStr: In this case it is provider specific
      if (pathParts.length < 4 || pathParts.at(-2) !== "tree") {
        return null;
      }

      return pathParts.at(-1)!;
    }

    return null;
  } catch (error) {
    return null;
  }
}

export type ComparisonFullResult = {
  diffTree: DiffTree,
  diffTreeSize: number,
} & ComparisonDifferences;

type ComparisonDifferences = {
  created: ComparisonData[],
  removed: ComparisonData[],
  changed: ComparisonData[],
  conflicts: ComparisonData[],
};


// TODO RadStr: Move it into package, used in both backend and DiffTree editor
/**
 * @returns The difftree and the total number of nodes in the difftree
*/
export async function compareTrees(
  filesystem1: FilesystemAbstraction,
  fakeTreeRoot1: DirectoryNode,
  globalFilesystemMapping1: Record<string, FilesystemNode>,
  filesystem2: FilesystemAbstraction,
  fakeTreeRoot2: DirectoryNode,
  globalFilesystemMapping2: Record<string, FilesystemNode>,
): Promise<ComparisonFullResult> {
  const diffTree: DiffTree = {};
  const changed: ComparisonData[] = [];
  const removed: ComparisonData[] = [];
  const created: ComparisonData[] = [];
  const conflicts: ComparisonData[] = [];


  const diffTreeSize = await compareTreesInternal(filesystem1, fakeTreeRoot1, globalFilesystemMapping1,
                                                  filesystem2, fakeTreeRoot2, globalFilesystemMapping2,
                                                  diffTree, {changed, removed, created, conflicts});
  return {
    changed,
    removed,
    created,
    conflicts,
    diffTree,
    diffTreeSize,
  };
}

// TODO RadStr: Move it into package, used in both backend and DiffTree editor
// TODO RadStr: Use objects instead of passing in separate values
/**
 * Compares the {@link directory1} to {@link directory2}. That is the {@link diffTree} will contain
 *  the removed entries from {@link directory1} compared to {@link directory2} and same for changed.
 *  The created ones will be those present in {@link directory2}, but not in {@link directory1}.
 *
 * @returns The number of nodes stored inside the {@link diffTree} (that is the difftree) computed in the method call.
 */
async function compareTreesInternal(
  filesystem1: FilesystemAbstraction,
  directory1: DirectoryNode | undefined,
  globalFilesystemMapping1: Record<string, FilesystemNode>,
  filesystem2: FilesystemAbstraction,
  directory2: DirectoryNode | undefined,
  globalFilesystemMapping2: Record<string, FilesystemNode>,
  diffTree: DiffTree,
  comparisonDifferences: ComparisonDifferences,
): Promise<number> {
  let diffTreeSize: number = 0;

  for (const [nodeName, nodeValue] of Object.entries(directory1?.content ?? {})) {
    diffTreeSize++;

    const node2Value = directory2?.content[nodeName];
    if (node2Value !== undefined && nodeValue.type !== node2Value.type) { // They are not of same type and both exists
      console.error("Tree comparison error - Compared entries have the same name however they are of different type. One is file, while the other is directory");
      throw new Error("Tree comparison error - Compared entries have the same name however they are of different type. One is file, while the other is directory");
    }

    const resourceComparisonResult: ResourceComparisonResult = node2Value === undefined ? "exists-in-old" : "exists-in-both";
    const currentlyProcessedDiffFilesystemNode: ResourceComparison = {
      childrenDiffTree: {},
      datastoreComparisons: [],
      resource: nodeValue,
      resourceComparisonResult,
    };
    diffTree[nodeName] = currentlyProcessedDiffFilesystemNode;

    // Recursively process "subdirectories"
    if (nodeValue.type === "directory") {
      const subtreeSize = await compareTreesInternal(filesystem1, nodeValue, globalFilesystemMapping1,
                                                      filesystem2, node2Value as (DirectoryNode | undefined), globalFilesystemMapping2,
                                                      currentlyProcessedDiffFilesystemNode.childrenDiffTree,
                                                      comparisonDifferences);
      diffTreeSize += subtreeSize;
    }

    const processedDatastoresInSecondTree: Set<DatastoreInfo> = new Set();
    for (const datastore1 of nodeValue.datastores) {
      diffTreeSize++;

      const node2Datastore = node2Value === undefined ? undefined : getDatastoreInfoOfGivenDatastoreType(node2Value, datastore1.type);
      if (node2Datastore !== undefined) {
        processedDatastoresInSecondTree.add(node2Datastore);

        if (await areDatastoresDifferent(filesystem1, nodeValue, filesystem2, node2Value as FileNode, datastore1)) {
          const changed: DatastoreComparison = {
            oldVersion: nodeValue,
            newVersion: node2Value ?? null,
            affectedDataStore: datastore1,
            datastoreComparisonResult: "modified",
          };
          currentlyProcessedDiffFilesystemNode.datastoreComparisons.push(changed);
          comparisonDifferences.changed.push(changed);
          comparisonDifferences.conflicts.push(changed);
        }
        else {
          const same: DatastoreComparison = {
            oldVersion: nodeValue,
            newVersion: node2Value ?? null,
            affectedDataStore: datastore1,
            datastoreComparisonResult: "same",
          };
          currentlyProcessedDiffFilesystemNode.datastoreComparisons.push(same);
        }
      }
      else {
        const removed: DatastoreComparison = {
          oldVersion: nodeValue,
          newVersion: null,
          affectedDataStore: datastore1,
          datastoreComparisonResult: "removed-in-new"
        };
        currentlyProcessedDiffFilesystemNode.datastoreComparisons.push(removed);
        comparisonDifferences.removed.push(removed);
      }
    }

    // Add those datastores which are present only in the second tree
    for (const datastore2 of node2Value?.datastores ?? []) {
      if (!processedDatastoresInSecondTree.has(datastore2)) {
        const created: DatastoreComparison = {
          oldVersion: null,
          newVersion: node2Value!,
          affectedDataStore: datastore2,
          datastoreComparisonResult: "created-in-new"
        };
        currentlyProcessedDiffFilesystemNode.datastoreComparisons.push(created);
        comparisonDifferences.created.push(created);
        diffTreeSize++;
      }
    }
  }

  // Find the filesystem nodes which are present only in the 2nd tree
  for (const [nodeName, nodeValue] of Object.entries(directory2?.content ?? {})) {
    if (diffTree[nodeName] !== undefined) {
      continue;
    }

    diffTreeSize++;
    const resourceComparisonResult: ResourceComparisonResult = "exists-in-new";
    const currentlyProcessedDiffFilesystemNode: ResourceComparison = {
      childrenDiffTree: {},
      datastoreComparisons: [],
      resource: nodeValue,
      resourceComparisonResult,
    };
    diffTree[nodeName] = currentlyProcessedDiffFilesystemNode;

    if (nodeValue.type === "directory") {
      const subtreeSize = await compareTreesInternal(filesystem1, undefined, globalFilesystemMapping1,
                                                      filesystem2, nodeValue, globalFilesystemMapping2,
                                                      currentlyProcessedDiffFilesystemNode.childrenDiffTree,
                                                      comparisonDifferences);
      diffTreeSize += subtreeSize;
    }

    for (const datastore of nodeValue.datastores) {
      // The datastore is not present, since the parent filesystem node does not exist, then it means that all of the datastores are not present neither
      const created: DatastoreComparison = {
        datastoreComparisonResult: "created-in-new",
        oldVersion: null,
        newVersion: nodeValue,
        affectedDataStore: datastore,
      };
      currentlyProcessedDiffFilesystemNode.datastoreComparisons.push(created);
      comparisonDifferences.created.push(created);
      diffTreeSize++;
    }
  }

  return diffTreeSize;
}


// TODO RadStr: Move it into package, used in both backend and DiffTree editor
async function areDatastoresDifferent(
  filesystem1: FilesystemAbstraction,
  entry1: FilesystemNode,      // TODO RadStr: Maybe I don't need the entry itself? ... I probably dont when using path, but when using full name I do
  filesystem2: FilesystemAbstraction,
  entry2: FilesystemNode,      // TODO RadStr: Maybe I don't need the entry itself?
  datastore: DatastoreInfo
): Promise<boolean> {
  // TODO RadStr: For now just assume, that there is always change
  const content1 = await filesystem1.getDatastoreContent(entry1.fullTreePath, datastore.type, true);
  const content2 = await filesystem2.getDatastoreContent(entry2.fullTreePath, datastore.type, true);

  console.info({content1, content2});    // TODO RadStr: DEBUG Print

  return !_.isEqual(content1, content2);
}


/**
 * Based on ChatGPT - it removes every "K" property from the type recursively
 */
type DeepOmit<T, K extends PropertyKey> = {
  [P in keyof T as P extends K ? never : P]:
    T[P] extends object ? DeepOmit<T[P], K> : T[P];
};

/**
 * Also ChatGPT
 * @deprecated No longer used, but it may be useful in future, so I keep it here
 */
export function deepOmit<T extends object>(obj: T, keyToRemove: string): any {
  if (Array.isArray(obj)) {
    return obj.map(item => deepOmit(item, keyToRemove));
  } else if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj)
        .filter(([k]) => k !== keyToRemove)
        .map(([k, v]) => [k, deepOmit(v, keyToRemove)])
    );
  }
  return obj;
}


/**
 * @returns true if the given value equals true ... for some reason zod does not like booleans so we do it explictly
 */
export function stringToBoolean(value: string): boolean {
  return value.toLowerCase() === "true";
}