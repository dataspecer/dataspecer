import { AccessToken, AccessTokenType, CommitterInfo, RepositoryURLPartBase } from "./git-provider-api.ts";
import _ from "lodash";


// TODO RadStr: Change to Dataspecer after debugging stage
export const GITHUB_USER_AGENT = "Dataspecer-test";


export type FinalizerVariantsForPullOnFailure = "remove-merge-state" | "pull-anyways";
export type FinalizerVariantsForPushOnFailure = "remove-merge-state";
export type FinalizerVariantsForMergeOnFailure = "remove-merge-state";

export type MergeCommitType = "merge-commit" | "rebase-commit";
export type CommitType = "classic-commit" | MergeCommitType;
export type SingleBranchCommitType = "classic-commit" | "rebase-commit";

export function isGitUrlSet(gitUrl: string | undefined | null): boolean {
  const length = gitUrl?.length;
  return length !== undefined && length > 0;
}

export const defaultEmptyGitUrlForDatabase = "";
export const defaultBranchForPackageInDatabase = "";


/**
 * Called for git related stuff - branch names, git user names, repository names
 * @returns the input {@link gitName} stripped by white space characters
 */
export function convertToValidGitName(gitName: string): string {
  // Based on ChatGPT
  const validGitName = gitName.trim().replace(/\s+/g, " ").replace(/ /g, "-");
  return validGitName;
}


export function createSetterWithGitValidation(setter: (value: string) => void) {
  return (newValueForSetter: string) => {
    const validValue = convertToValidGitName(newValueForSetter);
    setter(validValue);
  };
}


export function findPatAccessToken(accessTokens: AccessToken[] | null | undefined): AccessToken | null {
  const accessToken = accessTokens?.find(token => token.type === AccessTokenType.PAT);
  return accessToken ?? null;
}


export function findPatAccessTokens(accessTokens: AccessToken[] | null | undefined): AccessToken[] {
  const patAccessToken = accessTokens?.filter(token => token.type === AccessTokenType.PAT);
  return patAccessToken ?? [];
}


/**
 *
 * @param remoteRepoURLDomain is the domain part of URL without www., that is for example gitlab.com or github.com
 * @param accessTokenUserName is the name of the person pushing/committing or doing anything with the URL. When used in clone it can be any non-empty string.
 *  For others it is also proably ignored, the {@link accessToken} will be probably the important part for authentication.
 * @param repositoryOwner is the user under which the repository is created, that is the ending part of the url, that is for example github.com/{repositoryOwner}/{repoName}
 * @param repoName is the name of the repository to be used in the URL
 * @param accessToken is access token - Either from OAuth or PAT
 * @returns
 */
export const createRepoURLWithAuthorizationFromData = (remoteRepoURLDomain: string, accessTokenUserName: string, repositoryOwner: string, repoName: string, accessToken: string) => {
  return `https://${accessTokenUserName}:${accessToken}@${remoteRepoURLDomain}/${repositoryOwner}/${repoName}`;
};


/**
 * Transforms {@link remoteRepoURL} and calls {@link createRepoURLWithAuthorizationFromData}.
 * @param accessTokenUserName is the name of the person pushing/committing or doing anything with the URL
 * @param repositoryOwner is the user under which the repository is created, that is the ending part of the url, that is for example github.com/{repositoryOwner}/{repoName}
 */
const getHttpsRepoURLWithAuthorization = (remoteRepoURL: string, accessTokenUserName: string, repositoryOwner: string, repoName: string, accessToken: string): string => {
  const remoteRepoURLDomain = extractPartOfRepositoryURL(remoteRepoURL, "url-domain") ?? "github.com";
  return createRepoURLWithAuthorizationFromData(remoteRepoURLDomain, accessTokenUserName, repositoryOwner, repoName, accessToken);
};


export function getAuthorizationURL(
  committerInfo: CommitterInfo,
  accessToken: AccessToken,
  remoteRepositoryURL: string,
  repositoryOwner: string,
  repositoryName: string,
): string {
  let repoURLWithAuthorization: string;
  if (accessToken.type === AccessTokenType.SSH) {
    repoURLWithAuthorization = `git@${accessToken.value}:${repositoryOwner}/${repositoryName}.git`;
  }
  else if (accessToken.type === AccessTokenType.PAT) {
    repoURLWithAuthorization = getHttpsRepoURLWithAuthorization(remoteRepositoryURL, committerInfo.name, repositoryOwner, repositoryName, accessToken.value);
  }
  else {
    throw new Error(`Unknown access token type: ${accessToken.type}`);
  }

  return repoURLWithAuthorization;
}


export function createUniqueCommitMessage(): string {
  return "Autogenerated commit message " + Date.now();
}


/**
 * If the given {@link commitMessage} is of length 0, then it is transformed to null.
 * Otherwise the {@link commitMessage} is returned
 */
export function transformCommitMessageIfEmpty(commitMessage: string): string | null {
  const transformedCommitMessage = commitMessage.length === 0 ? null : commitMessage;
  return transformedCommitMessage;
}


/**
 * If you want to extract something more then use the same method on Git Provider.
 * @param repositoryURL is the URL of the repository
 * @returns The part of given URL. Where the given URL can either be the main page
 *  (for example https://github.com/mff-uk/dataspecer) or some of the branches (for example https://github.com/mff-uk/dataspecer/tree/stable).
 *  Should also work for gitlab or any other git providers following similar URL structure.
 *  In the example mff-uk is "repository-owner" and dataspecer is "repository-name".
 *  For "branch" returns null, if it not explicitly provided in the {@link repositoryURL}.
 */
export function extractPartOfRepositoryURL(repositoryURL: string, part: RepositoryURLPartBase): string | null {
  try {
    const parsedUrl = new URL(repositoryURL);

    if (part === "url-domain") {
      return parsedUrl.host;
    }

    const pathParts = parsedUrl.pathname.split("/").filter(part => part.length > 0);

    if (pathParts.length < 2) {
      return null;
    }

    // Where pathParts = ["mff-uk", "dataspecer", "tree", "stable"] for the above example
    if (part === "repository-name") {
      return pathParts[1];
    }
    else if (part === "repository-owner") {
      return pathParts[0];
    }

    return null;
  } catch (error) {
    return null;
  }
}


/**
 * Based on ChatGPT - it removes every "K" property from the type recursively
 */
type DeepOmit<T, K extends PropertyKey> = {
  [P in keyof T as P extends K ? never : P]:
    T[P] extends object ? DeepOmit<T[P], K> : T[P];
};


/**
 * Also ChatGPT
 * @deprecated No longer used, but it may be useful in future, so I keep it here
 */
export function deepOmit<T extends object>(obj: T, keyToRemove: string): any {
  if (Array.isArray(obj)) {
    return obj.map(item => deepOmit(item, keyToRemove));
  } else if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj)
        .filter(([k]) => k !== keyToRemove)
        .map(([k, v]) => [k, deepOmit(v, keyToRemove)])
    );
  }
  return obj;
}


/**
 * @returns true if the given value equals true ... for some reason zod does not like booleans so we do it explictly
 */
export function stringToBoolean(value: string): boolean {
  return value.toLowerCase() === "true";
}
