import _ from "lodash";
import { SimpleGit } from "simple-git";
import fs from "fs";
import path from "path";
import child_process from "child_process";
import os from "os";


export async function getLastCommitHash(git: SimpleGit) {
  const gitLastCommitHash = await git.revparse(["HEAD"]);
  return gitLastCommitHash;
}

export async function getLastCommit(git: SimpleGit) {
  return (await git.log({ maxCount: 1 })).latest;
}

/**
 * Removes everything inside the {@link rootDirectory} in filesystem, except the given {@link exceptions}. The exceptions should be the name of entries to skip inside the dir.
 */
export function removeEverythingExcept(rootDirectory: string, exceptions: string[]) {
  const directoryEntries = fs.readdirSync(rootDirectory);

  for (const entry of directoryEntries) {
    if (exceptions.includes(entry)) {
      continue;
    }

    const fullPath = path.join(rootDirectory, entry);
    removePathRecursively(fullPath);
  }
}

/**
 * Just calls fs.rmSync(path, { recursive: true, force: true }); to remove everything on path and further
 */
export function removePathRecursively(path: string) {
  fs.rmSync(path, { recursive: true, force: true });
}

/**
 * @param gitLink is used only to provide the correct error message
 * @throws Throws error if {@link repoName} or {@link repositoryOwner} are null
 */
export function checkErrorBoundaryForCommitAction(
  gitLink: string,
  repoName: string | null,
  repositoryOwner: string | null,
): repoName is NonNullable<string> {
  if (repoName === null) {
    throw new Error(`Repository name could not be extracted from the repository URL: ${gitLink}`);
  }
  if (repositoryOwner === null) {
    throw new Error(`Repository owner could not be extracted from the repository URL: ${gitLink}`);
  }

  return true;
}

/**
 * The reason for existence of this method lies in the fact that user (this is always the case when running in docker), may have not defined the
 * github as known host. Therefore the action of committing would need confirmation, which can not provide if running from application, so we fail with error.
 */
export function populateSshKnownHosts() {
  addGitHubHostKeyToSshKnownHosts();
}

export function setSshChmod() {
  // const sshDir = path.join(os.homedir(), ".ssh");
  // const uid = process.getuid();
  // const gid = process.getgid();
  // const knownHosts = path.join(sshDir, "known_hosts");
  // console.info({uid, gid, knownHosts, sshDir});
  // try {
  //   // fs.chownSync(knownHosts, uid, gid);
  //   fs.chmodSync(knownHosts, 0o644);
  // }
  // catch(error) {
  //   console.error(`Could not set the ${knownHosts} chmod to 644`);
  // }
  // try {
  //   // fs.chownSync(sshDir, uid, gid);
  //   fs.chmodSync(sshDir, 0o700);
  // }
  // catch(error) {
  //   console.error(`Could not set the ${sshDir} (.ssh dir) chmod to 700`);
  // }
}

/**
 * Generated by ChatGPT
 */
function addGitHubHostKeyToSshKnownHosts() {
  const sshDir = path.join(os.homedir(), ".ssh");
  const knownHosts = path.join(sshDir, "known_hosts");

  // Ensure ~/.ssh exists
  if (!fs.existsSync(sshDir)) {
    fs.mkdirSync(sshDir, { mode: 0o700 });
  }

  child_process.exec("ssh-keyscan -t ed25519 github.com", (error, stdout) => {
    let existingContent = "";
    let knownHostsExist: boolean;
    if (fs.existsSync(knownHosts)) {
      existingContent = fs.readFileSync(knownHosts, "utf8");
      knownHostsExist = true;
    }
    else {
      knownHostsExist = false;
    }

    // Check if ANY line in known_hosts is for "github.com"
    const hasGitHubEntry = existingContent
      .split("\n")
      .some(line => line.startsWith("github.com ssh-ed25519 "));

    if (error) {
      if (error.code === 1) {
        // We are most-likely on windows and windows usually has some weird implementation of ssh, which does not suppory the ssh-keyscan (unsupported KEX method)
        if (!hasGitHubEntry) {
          // https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
          const gitHubKnownHostsExtension = `github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=`
          fs.appendFileSync(knownHosts, gitHubKnownHostsExtension);
          if (!knownHostsExist) {
            fs.chmodSync(knownHosts, 0o644);
          }
        }
      }
      else {
        // TODO RadStr Debug: Debug print
        console.error("ssh-keyscan failed:", error);
      }
      return;
    }

    if (!hasGitHubEntry) {
      fs.appendFileSync(knownHosts, stdout);
      if (!knownHostsExist) {
        fs.chmodSync(knownHosts, 0o644);
      }
    }
  });
}

/**
 * When working with auth, we are checking if the urls match certain values. For that we need to strip the /api away in cases when it is present.
 * For example when running in Docker. When it is not present we returned the {@link url} unchanged (for example when running locally with locahost:3100)
 */
export function stripApiPrefixFromUrl(url: string): string {
  if (url.startsWith("/api")) {
    return url.substring(4);
  }
  return url;
}



/**
 * Generated by ChatGPT
 * Checks out if given {@link branchName} is a default branch for {@link git} instance.
 * It checks it out using "refs/remotes/origin/HEAD", therefore the git has to be linked to remote
 */
export async function isDefaultBranch(
  git: SimpleGit,
  branchName: string
): Promise<boolean> {

  // 1. Try to read origin/HEAD symbolic ref
  try {
    const ref = await git.raw([
      "symbolic-ref",
      "--short",
      "refs/remotes/origin/HEAD"
    ]);

    const remoteDefault = ref.trim().replace(/^origin\//, "");
    return remoteDefault === branchName;
  } catch {
    // ignore: origin/HEAD may not exist
  }

  // 2. Fallback: parse "git remote show origin"
  try {
    const output = await git.raw(["remote", "show", "origin"]);
    const match = output.match(/HEAD branch:\s+(\S+)/);

    if (match) {
      const remoteDefault = match[1].trim();
      return remoteDefault === branchName;
    }
  } catch {
    // ignore errors
  }

  // 3. Last fallback: no reliable default found
  return false;
}
