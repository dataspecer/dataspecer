import fs from "fs";
import path from "path";
import os from "os";
import { GitProviderNamesAsType, isGitProviderName } from "@dataspecer/git";


/**
 * Generated by ChatGPT
 */
function wrapPrivateKey(keyData: string, type: "RSA" | "OPENSSH" = "OPENSSH"): string {
  // Normalize: remove whitespace/newlines
  const cleanKey = keyData.replace(/\s+/g, "");

  // Split into 64-character lines (PEM standard)
  const formattedKey = cleanKey.match(/.{1,64}/g)?.join("\n") ?? cleanKey;

  // Not ChatGPT - but I noticed that it has to end with empty line
  return `-----BEGIN ${type} PRIVATE KEY-----\n${formattedKey}\n-----END ${type} PRIVATE KEY-----\n`;
}

/**
 * We need this because the path inside ssh config file does not seem to correctly work for absolute paths,
 *  it either has to be relative, or C:/ has to be converted to /c/
 */
const relativizeAgainstSshInHomeDir = (givenPath: string): string => {
  const relativeAgainstSshInHomeDir = path.relative(path.join(os.homedir(), ".ssh"), givenPath);
  return convertToPosixPath(relativeAgainstSshInHomeDir);
};

export const convertToPosixPath = (givenPath: string): string => {
  return givenPath.replace(/\\/g, "/");
};


export const createUserSSHIdentifier = (authenticatedUser: any | null | undefined): string | null => {
  if (authenticatedUser === null || authenticatedUser === undefined) {
    return null;
  }
  const userSSHIdentifer = `${authenticatedUser.accountProvider}-${authenticatedUser.providerAccountId}`;
  return userSSHIdentifer;
};

/**
 * @param pathToSSHForDS is usually "./database/ds-users/.ssh" it is the path to .ssh but for the DS
 * @param pathToSSHConfigForDS usually the "{@link pathToSSHForDS}/config"
 */
export function storeNewPrivateSSHKeyToBackend(
  privateSSHKey: string,
  userSSHIdentifer: string | null,
  gitProviderName: GitProviderNamesAsType,
  pathToSSHForDS: string,
  pathToSSHConfigForDS: string,
) {
  if (!isGitProviderName(gitProviderName)) {
    throw new Error("Not a GitProviderNamesAsType");
  }
  if (gitProviderName !== "github") {
    throw new Error("TODO: Only github is currently supported for sshs, you need to rewrite the subsequents methods first. Basically do the same thing as for github, but for other providers");
  }

  const pathToHomeDirectorySShConfig = path.join(os.homedir(), ".ssh", "config");
  const pathToSSHConfigForDSRelativeToHomeDir = relativizeAgainstSshInHomeDir(pathToSSHConfigForDS);
  const fileContent = wrapPrivateKey(privateSSHKey);

  fs.mkdirSync(pathToSSHForDS, { recursive: true });

  const privateSSHKeyFilePath = convertToPosixPath(path.normalize(`${pathToSSHForDS}/private-ssh-key-${userSSHIdentifer}`));
  fs.writeFileSync(privateSSHKeyFilePath, fileContent);
  fs.chmodSync(privateSSHKeyFilePath, 0o600);

  // Hardcoded for github
  const configIdentifier = `Host ${userSSHIdentifer}`;
  const identityFileLine = `    IdentityFile ${privateSSHKeyFilePath}`;
  const newConfigEntry = `${configIdentifier}
    HostName github.com
    User git
${identityFileLine}\n\n`;

  if (!replaceSSHConfigEntry(pathToSSHConfigForDS, configIdentifier, identityFileLine)) {
    fs.appendFileSync(pathToSSHConfigForDS, newConfigEntry);     // It was not present, just append it
  }

  // Include our config into the config in home directory
  const theIncludesStringForConfig = `Include ${pathToSSHConfigForDSRelativeToHomeDir}`;
  if (!fs.existsSync(pathToHomeDirectorySShConfig)) {
    const sshDir = path.dirname(pathToHomeDirectorySShConfig);
    fs.mkdirSync(sshDir, { recursive: true }); // Ensures all needed dirs exist (needed for the docker)
    fs.writeFileSync(pathToHomeDirectorySShConfig, theIncludesStringForConfig);
  }
  else {
    if (!fs.readFileSync(pathToHomeDirectorySShConfig).includes(theIncludesStringForConfig)) {
      fs.appendFileSync(pathToHomeDirectorySShConfig, `\n${theIncludesStringForConfig}`);
    }
  }
}


/**
 * Generated with ChatGPT's help
 * Replaces the entry if it was present.
 * @returns True if the entry was present, false if it was not.
 */
function replaceSSHConfigEntry(filePath: string, matchLineToReplace: string, identityFileLine: string): boolean {
  const { index, lines } = splitIntoLinesAndCheckForMatchingLine(filePath, matchLineToReplace);
  if (index < 0) {
    return false;
  }

  // Replace the path
  lines[index + 3] = identityFileLine;

  // Write back to file
  fs.writeFileSync(filePath, lines.join("\n"), "utf-8");

  return true;
}

export function splitIntoLinesAndCheckForMatchingLine(filePath: string, matchLineToReplace: string): { index: number, lines: string[] } {
  // Read file into array of lines
  let lines: string[];
  try {
    lines = fs.readFileSync(filePath, "utf-8").split(/\r?\n/);
  }
  catch (error) {
    return {
      index: -2,
      lines: [],
    };
  }

  // Find the index of the matching line
  const index = lines.findIndex(line => line.includes(matchLineToReplace));

  if (index === -1) {
    return {
      index: -1,
      lines,
    };
  }

  return {
    index,
    lines,
  };
}
