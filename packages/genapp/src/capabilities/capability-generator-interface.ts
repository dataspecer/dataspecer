import { LayerArtifact } from "../engine/layer-artifact";
import { GenerationContext } from "../engine/generator-stage-interface";
import { GeneratorPipeline } from "../engine/generator-pipeline";
import { AggregateMetadata } from "../application-config";
import { CapabilityType } from ".";
import { ApplicationGraph, ApplicationGraphNode, NodeConfiguration } from "../engine/graph";

/**
 * Interface used to represent the metadata of a capability generator.
 */
interface CapabilityGeneratorMetadata {
    /**
     * Gets the type to indicate the type of capability being generated by the generator instance,
     * which implements this interface. Currently, "collection" and "instance" values are supported.
     */
    getType(): CapabilityType;
    getLabel(): string;
    getHumanLabel(): string;
    getIdentifier(): string;
}

interface CapabilityConfiguration {
    aggregate: AggregateMetadata,
    graph: ApplicationGraph;
    node: ApplicationGraphNode;
    nodeConfig: NodeConfiguration;
}

/**
 * Abstract class representing metadata for an instance capability generator.
 * All capability generators inheriting from this base class are expected to generate
 * instance capabilities, i.e. capabilities which are executed on an instance of a class.
 *
 * @abstract
 */
export abstract class InstanceCapabilityMetadata implements CapabilityGeneratorMetadata {
    abstract getLabel(): string;
    abstract getIdentifier(): string;

    private readonly _humanLabel: string;

    constructor(label: string) {
        this._humanLabel = label;
    }

    /**
     * Returns the "instance" capability type indication.
     */
    getType = (): CapabilityType => CapabilityType.Instance;
    getHumanLabel = (): string => this._humanLabel;
}

/**
 * Abstract class representing metadata for an "aggregate" capability generator.
 * All capability generators inheriting from this base class are expected to generate
 * aggregate-level capabilities, i.e. capabilities which do not need a specific instance in order to be executed (
 * can be looked at as "static" capabilities).
 *
 * @abstract
 */
export abstract class AggregateCapabilityMetadata implements CapabilityGeneratorMetadata{
    abstract getLabel(): string;
    abstract getIdentifier(): string;

    private readonly _humanLabel: string;

    constructor(label: string) {
        this._humanLabel = label;
    }

    /**
     * Returns the "collection" capability type indication.
    */
   getType = (): CapabilityType => CapabilityType.Collection;
   getHumanLabel = (): string => this._humanLabel;
}

export interface CapabilityGenerator extends CapabilityGeneratorMetadata {
    generateCapability(config: CapabilityConfiguration): Promise<LayerArtifact>;
}

/**
 * Common base class for capability generators, which provides a base implementation to generate a capability.
 * In this case, the provided pipeline containing definition of capability layers is used in order to generate a capability.
 * Therefore, specific capability generators only need to provide a definition of required layers within the pipeline.
 * Capability-specific metadata included within @see {CapabilityGeneratorMetadata} are left to be implemented by the specific generator classes.
 */
export abstract class BaseCapabilityGenerator implements CapabilityGenerator, CapabilityGeneratorMetadata {

    private readonly _capabilityMetadata: CapabilityGeneratorMetadata;

    /**
     * Pipeline responsible for executing all stages of capability-based code generation.
     * @protected
     */
    protected _capabilityStagesGeneratorPipeline: GeneratorPipeline = null!;
    protected readonly _aggregateMetadata: AggregateMetadata;

    constructor(aggregateMetadata: AggregateMetadata, capabilityMetadata: CapabilityGeneratorMetadata) {
        this._aggregateMetadata = aggregateMetadata;
        this._capabilityMetadata = capabilityMetadata;
    }

    getLabel = (): string => this._capabilityMetadata.getLabel();
    getType = (): CapabilityType => this._capabilityMetadata.getType();
    getIdentifier = (): string => this._capabilityMetadata.getIdentifier();
    getHumanLabel = (): string => this._capabilityMetadata.getHumanLabel();

    /**
     * Converts a capability configuration to a generation context.
     *
     * @param config - The capability configuration to convert.
     * @returns The converted generation context.
     */
    private convertToGenerationContext(config: CapabilityConfiguration): GenerationContext {
        const converted: GenerationContext = {
            aggregate: config.aggregate,
            graph: config.graph,
            currentNode: config.node,
            config: config.nodeConfig,
            _: {}
        };

        return converted;
    }

    /**
     * Generates a capability based on the provided configuration.
     *
     * @param config - The capability configuration.
     * @returns A promise that resolves to a `LayerArtifact` which represents the last generated source file for the corresponding capability.
     */
    generateCapability(config: CapabilityConfiguration): Promise<LayerArtifact> {
        const generationContext = this.convertToGenerationContext(config);

        return this
            ._capabilityStagesGeneratorPipeline
            .generateStages(generationContext);
    }
}
