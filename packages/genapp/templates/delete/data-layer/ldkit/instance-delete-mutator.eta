import { QueryContext, createLens, QueryEngine, Options } from "ldkit";
import { <%= it.instance_result_type %> } from <%~ it.instance_result_type_path %>;
import { <%= it.ldkit_schema %> } from <%~ it.ldkit_schema_path %>;
import { <%= it.delete_mutator_interface_type %> } from <%~ it.delete_mutator_interface_type_path %>;

class LdkitDeleteQueryEngine extends QueryEngine {

    override query(query: string, responseType: string, context?: QueryContext): Promise<Response> {
        const endpoint = this.getSparqlEndpoint(context);
        const fetchFn = this.getFetch(context);
        return fetchFn(endpoint, {
            method: "POST",
            headers: {
                "accept": responseType,
                "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
            },
            body: new URLSearchParams({
                update: query,
            }),
        });
    }

}

export class <%= it.exported_object_name %> implements <%= it.delete_mutator_interface_type %> {

    private _customEngine: QueryEngine;

    constructor() {
        this._customEngine = new LdkitDeleteQueryEngine();
    }

    async deleteInstance(instanceIri: string): Promise<<%= it.instance_result_type %>> {
        return this.executeDelete(instanceIri, <%= it.ldkit_schema %>);
    }

    private async getInstanceByIri(iri: string, schema: any) {
        const options: Options = {
            sources: ["<%~ it.sparql_endpoint_uri.read %>"]
        }

        const lens = createLens(schema, options);
        return lens.findByIri(iri);
    }

    private async deleteNestedObjects(toDelete: object, schema: any) {
        for (const [key, value] of Object.entries<any>(schema)) {
            if ((typeof value === "string") || !value["@schema"]) {
                continue;
            }

            const nestedSchema = value["@schema"];
            const nestedValue = toDelete[key];

            if (!nestedValue) {
                continue;
            }

            if (Array.isArray(nestedValue)) {
                for (const nestedItem of nestedValue) {
                    const nestedIri = nestedItem["$id"];
                    await this.executeDelete(nestedIri, nestedSchema);
                }
            } else {
                const nestedIri = nestedValue["$id"];
                await this.executeDelete(nestedIri, nestedSchema);
            }
        }
    }

    private async executeDelete(instanceIri: string, schema: any): Promise<<%= it.instance_result_type %>> {
        const toDelete = await this.getInstanceByIri(instanceIri, schema);

        if (!toDelete) {
            const notFoundResult: <%= it.instance_result_type %> = {
                instance: null,
                message: "Could not find the instance to be deleted.",
                redirectUrl: "/"
            }

            return notFoundResult;
        }

        let result: <%= it.instance_result_type %>;

        try {
            await this.deleteNestedObjects(toDelete, schema);

            const deleteLens = createLens(schema, {
                sources: ["<%~ it.sparql_endpoint_uri.write %>"],
                engine: this._customEngine
            });
            await deleteLens.delete(toDelete);

            result = {
                instance: {
                    aggregateName: "<%= it.aggregate_name %>",
                    raw: toDelete.$id
                },
                message: "Instance deleted successfully",
                redirectUrl: "/"
            }  as <%= it.instance_result_type %>;

        } catch {
            result = {
                instance: null,
                message: "Could not delete instance.",
                redirectUrl: "/"
            } as <%= it.instance_result_type %>;
        }

        return result;
    }
}
