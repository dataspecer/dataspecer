import { QueryContext, createLens, QueryEngine, Options } from "ldkit";
import { <%= it.instance_result_type %> } from <%~ it.instance_result_type_path %>;
import { <%= it.ldkit_schema %> } from <%~ it.ldkit_schema_path %>;
import { <%= it.editor_interface_type %> } from <%~ it.editor_interface_type_path %>;
import { IriGenerator, UUIDGenerator } from "../../../uuid-generator.ts";

class LdkitEditorQueryEngine extends QueryEngine {

    override query(query: string, responseType: string, context?: QueryContext): Promise<Response> {
        const endpoint = this.getSparqlEndpoint(context);
        const fetchFn = this.getFetch(context);
        return fetchFn(endpoint, {
            method: "POST",
            headers: {
                "accept": responseType,
                "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
            },
            body: new URLSearchParams({
                update: query,
            }),
        });
    }

}

export class <%= it.exported_object_name %> implements <%= it.editor_interface_type %>  {

    private _customEngine: QueryEngine;
    private readonly _idGenerator: IIdentifierGenerator; // TODO

    constructor() {
        this._customEngine = new LdkitEditorQueryEngine();
        this._idGenerator = UUIDGenerator.getGenerator(); // TODO
    }

    async updateInstance(formData: object): Promise<<%= it.instance_result_type %>> {
        return this.executeUpdate(formData, <%= it.ldkit_schema %>);
    }

    private async executeUpdate(formData: object, schema: any): Promise<<%= it.instance_result_type %>> {

        const options: Options = {
            sources: ["<%~ it.sparql_endpoint_uri.write %>"],
            engine: this._customEngine
        };

        try {
            await this.updateNestedObjects(formData, schema);
            const toUpdate = this.mapFormDataToLdkitEntity(formData, schema);

            let lens = createLens(schema, { sources: ["<%~ it.sparql_endpoint_uri.read %>"] });
            const existingInstance = await lens.findByIri(toUpdate["$id"]);

            lens = createLens(schema, options);

            const promise: Promise<void> = !existingInstance
                ? lens.insert(toUpdate)
                : lens.update(toUpdate);
            await promise;

            const result: <%= it.instance_result_type %> = {
                instance: {
                    aggregateName: "<%= it.aggregate_name %>",
                    raw: toUpdate.$id
                },
                message: "Instance updated successfully",
                redirectUrl: "/"
            }

            return result;
        } catch (error) {
            const errorResult: <%= it.instance_result_type %> = {
                instance: null,
                message: "Instance update failed",
                redirectUrl: "/"
            };

            return errorResult;
        }
    }

    private mapFormDataToLdkitEntity(formData: object, schema: any) {
        const toUpdate = this.updateLdkitProperties(formData, schema);

        return {
            ...toUpdate,
            "$id": ("$id" in toUpdate)
                ? toUpdate["$id"]
                : this._idGenerator.generateIri()
        };
    }

    private updateLdkitProperties(obj: any, schema: any) {

        if (typeof obj !== "object" || !obj) {
            return obj;
        }

        const transformed = Object.entries(obj)
            .map(([key, value]) => {
                if (key === "id") {
                    return ["$id", value];
                }

                if (key === "@type") {
                    return ["$type", value];
                }

                const nestedSchema = schema[key]["@schema"];

                if (Array.isArray(value)) {
                    if (nestedSchema) {
                        return [key, value.map(item => this.updateLdkitProperties(item, nestedSchema))];
                    }

                    return [key, value];
                }

                if (nestedSchema && !(value instanceof Date)) {
                    return [key, this.updateLdkitProperties(value, nestedSchema)];
                }

                return [key, value];
            })
            .concat([["$type", schema["@type"]]]);

        return Object.fromEntries(transformed);
    }

    private async updateNestedObjects(toUpdate: object, schema: any) {
        for (const [key, value] of Object.entries(schema || {})) {
            if ((typeof value === "string") || !value["@schema"]) {
                // current property does not refer to an object
                continue;
            }

            const nestedSchema = value["@schema"];
            const nestedValue = toUpdate[key];

            if (!nestedValue) {
                continue;
            }

            const nestedItems = Array.isArray(nestedValue)
                ? nestedValue
                : [nestedValue];

            for (const nestedItem of nestedItems) {
                // TODO: create link from parent to nested object (for created ones)
                await this.executeUpdate(nestedItem, nestedSchema);
            }
        }
    }
}
