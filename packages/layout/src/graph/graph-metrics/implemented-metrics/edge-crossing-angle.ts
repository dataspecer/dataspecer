
import { Edge } from "../../representation/edge.ts";
import { DefaultGraph, Graph } from "../../representation/graph.ts";
import { AllMetricData, ComputedMetricValues, Metric } from "../graph-metric.ts";
import { EdgeCrossingMetric } from "./edge-crossing.ts";


// Generated by ChatGPT
function calculateAngleBetweenVectors(a: number[], b: number[]): number {
  // Step 1: Calculate the dot product
  const dotProduct = a.reduce((sum, ai, i) => sum + ai * b[i], 0);

  // Step 2: Calculate the magnitudes of each vector
  const magnitudeA = Math.sqrt(a.reduce((sum, ai) => sum + ai ** 2, 0));
  const magnitudeB = Math.sqrt(b.reduce((sum, bi) => sum + bi ** 2, 0));

  if (magnitudeA === 0 || magnitudeB === 0) {
    throw new Error("Vectors must not be zero vectors.");
  }

  // Step 3: Calculate the cosine of the angle
  const cosTheta = dotProduct / (magnitudeA * magnitudeB);

  // Ensure the value is clamped to the valid range [-1, 1] to avoid NaN due to floating point errors
  const clampedCosTheta = Math.max(-1, Math.min(1, cosTheta));

  // Step 4: Calculate the angle in radians
  const angleRadians = Math.acos(clampedCosTheta);

  // Step 5: Convert radians to degrees
  const angleDegrees = angleRadians * (180 / Math.PI);
  const secondAngleDegrees = (360 - 2 * angleDegrees) / 2;
  // Choose the smaller of the 2 angles (the acute one), so the result is always in [0, 1] range
  return Math.min(angleDegrees, secondAngleDegrees);
}

function createVectorFromEdge(edge: Edge) {
  const vector = [
    edge.end.completeVisualNode.coreVisualNode.position.x - edge.start.completeVisualNode.coreVisualNode.position.x,
    edge.end.completeVisualNode.coreVisualNode.position.y - edge.start.completeVisualNode.coreVisualNode.position.y,
  ];

  return vector;
}


/**
 * Metric which caculates the angle between edges, see https://github.com/rpgove/greadability or https://osf.io/preprints/osf/wgzn5_v1
 * optimal seems to be 70 degrees
 */
export class EdgeCrossingAngleMetric implements Metric {
    computeMetric(graph: Graph): ComputedMetricValues {
      const idealAngle = 70;
      let crossCount = 0;
      let angleDifferenceSum = 0;
      const edges = graph.mainGraph.getAllEdgesInMainGraph();
      for(let i = 0; i < edges.length; i++) {
        for(let j = i; j < edges.length; j++) {
          const edge1 = edges[i];
          const edge2 = edges[j];

          const vector1 = createVectorFromEdge(edge1);
          const vector2 = createVectorFromEdge(edge2);
          if((vector1[0] === 0 && vector1[1] === 0) || (vector2[0] === 0 && vector2[1] === 0)) {
            continue;
          }

          const areEdgesCrossing = EdgeCrossingMetric.isEdgeCrossForStraightLines(
            edge1.start.completeVisualNode, edge1.end.completeVisualNode,
            edge2.start.completeVisualNode, edge2.end.completeVisualNode);
          if(!areEdgesCrossing) {
            continue;
          }
          const angle = calculateAngleBetweenVectors(vector1, vector2);
          // https://github.com/rpgove/greadability
          angleDifferenceSum += Math.abs(idealAngle - angle);
          crossCount++;
        }
      }

      // Based on page 3 in https://osf.io/preprints/osf/wgzn5_v1
      const denominator = crossCount * idealAngle;
      if(denominator === 0) {
        return {
          absoluteValue: 0,
          relativeValue: 1
        };
      }

      return {
        absoluteValue: angleDifferenceSum / denominator,
        relativeValue: 1 - (angleDifferenceSum / denominator),
      }
    }

    computeMetricForNodes(graph: Graph): Record<string, ComputedMetricValues> {
        throw new Error("Method not implemented.");
    }
    computeMetricForEdges(graph: Graph): Record<string, ComputedMetricValues> {
        throw new Error("Method not implemented.");
    }
    computeMetricsForEverything(graph: Graph): AllMetricData {
        throw new Error("Method not implemented.");
    }

}
