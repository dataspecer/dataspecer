import { CmeSemanticModel, filterWritableModels } from "../../dataspecer/cme-model";
import { validationNoProblem, ValidationState } from "../utilities/validation-utilities";
import { InvalidState } from "../../application/error";
import { createLogger } from "../../application";
import { generateName } from "../../util/name-utils";
import { isRelativeIri } from "../../utilities/iri";
import { LanguageString, UNDEFINED_MODEL } from "../../dataspecer/entity-model";
import { EntityRepresentative, sortRepresentatives } from "../utilities/dialog-utilities";
import { sanitizeDuplicitiesInRepresentativeLabels } from "../../utilities/label";
import { isSemanticModelGeneralization } from "@dataspecer/core-v2/semantic-model/concepts";
import { CmeReference, CmeSpecialization, NewCmeSpecialization } from "../../dataspecer/cme-model/model";
import { InMemorySemanticModel } from "@dataspecer/core-v2/semantic-model/in-memory";
import { EntityModel } from "@dataspecer/core-v2";
import { isInMemorySemanticModel } from "../../utilities/model";

const LOG = createLogger(import.meta.url);

export interface BaseEntityDialogState {

  /**
   * Primary data language for the dialog.
   */
  language: string;

  /**
   * List of all models.
   * We use this to update entities.
   */
  allModels: CmeSemanticModel[];

  /**
   * List of all writable models which can be selected to own the entity.
   */
  availableModels: CmeSemanticModel[];

  /**
   * Entity owner.
   */
  model: CmeSemanticModel;

  /**
   * When true the dialog do not allow for change of model.
   */
  disableModelChange: boolean;

  /**
   * IRI for given entity. The meaning depends on the edited entity.
   */
  iri: string;

  /**
   * If true, change in name result in generation of IRI.
   */
  isIriAutogenerated: boolean;

  /**
   * If true the IRI is relative with respect to model.
   */
  isIriRelative: boolean;

  /**
   * Validation message for IRI.
   */
  iriValidation: ValidationState;

  /**
   * Entity name.
   */
  name: LanguageString;

  /**
   * Entity description.
   */
  description: LanguageString;

  /**
   * List of available specializations we can utilize.
   */
  availableSpecializations: EntityRepresentative[];

  /**
   * List of active specializations.
   */
  specializations: NewCmeSpecialization[];

  /**
   * Link to external documentation.
   */
  externalDocumentationUrl: string;

}

/**
 * Create state for new entity in the default model.
 *
 * @param allSpecializations Possible specializations.
 * @throws InvalidState
 */
export function createNewBaseEntityDialogState(
  language: string,
  defaultModelIdentifier: string | null,
  allModels: CmeSemanticModel[],
  allSpecializations: EntityRepresentative[],
  generateIriFromName: (name: string) => string,
): BaseEntityDialogState {
  const writableModels = prepareWritableModels(allModels);
  const model = findByIdentifier(writableModels, defaultModelIdentifier)
    ?? writableModels[0];

  const name = generateName();

  const availableSpecializations = sanitizeDuplicitiesInRepresentativeLabels(
    allModels, allSpecializations);
  sortRepresentatives(language, availableSpecializations);

  return {
    language,
    // Model
    allModels: allModels,
    availableModels: writableModels,
    model,
    disableModelChange: false,
    // IRI
    iri: generateIriFromName(name),
    isIriAutogenerated: true,
    isIriRelative: true,
    iriValidation: validationNoProblem(),
    // Name
    name: { [language]: name },
    // Description
    description: {},
    // Specialization
    availableSpecializations,
    specializations: [],
    // Documentation
    externalDocumentationUrl: "",
  };
}

/**
 * @throws InvalidState
 */
function prepareWritableModels(models: CmeSemanticModel[]) {
  const result = filterWritableModels(models);
  if (result.length === 0) {
    LOG.error("There is no writable model.");
    throw new InvalidState();
  }
  return result;
}

function findByIdentifier<Type extends { identifier: string }>(
  items: Type[], identifier: string | null,
): Type | null {
  if (identifier === null) {
    return null;
  }
  return items.find(item => item.identifier === identifier) ?? null;
}

/**
 * Create state for existing entity that exists in given model.
 * Change of model is not allowed.
 *
 * @param allSpecializations Possible specializations.
 * @param generalizations All generalization.
 * @throws InvalidState
 */
export function createEditBaseEntityDialogState(
  language: string,
  entityModels: Map<string, EntityModel>,
  allModels: CmeSemanticModel[],
  entity: CmeReference,
  iri: string,
  name: LanguageString,
  description: LanguageString,
  externalDocumentationUrl: string,
  allSpecializations: EntityRepresentative[],
): BaseEntityDialogState {

  const semanticModels: InMemorySemanticModel[] =
    [...entityModels.values()].filter(isInMemorySemanticModel);

  const writableModels = prepareWritableModels(allModels);
  const model = findByIdentifier(writableModels, entity.model);
  if (model === null) {
    LOG.error("Missing required model.",);
    throw new InvalidState();
  }

  // We remove current entity from the specialization list.
  const availableSpecializations = sanitizeDuplicitiesInRepresentativeLabels(
    allModels, allSpecializations.filter(item => item.identifier !== entity.identifier));
  sortRepresentatives(language, availableSpecializations);

  return {
    language,
    // Model
    allModels: allModels,
    availableModels: writableModels,
    model,
    disableModelChange: true,
    // IRI
    iri,
    isIriAutogenerated: false,
    isIriRelative: isRelativeIri(iri),
    iriValidation: validationNoProblem(),
    // Name
    name,
    // Description
    description,
    // Specialization
    availableSpecializations,
    specializations: representSpecializations(
      entity.identifier, allSpecializations, semanticModels),
    // Documentation
    externalDocumentationUrl,
  };
}

// Same function is in base-entity-profile-dialog-state
function representSpecializations(
  identifier: string,
  allSpecializations: EntityRepresentative[],
  semanticModels: InMemorySemanticModel[],
): CmeSpecialization[] {
  const result: CmeSpecialization[] = []
  // We need to search for all generalizations.
  for (const model of semanticModels) {
    for (const entity of Object.values(model.getEntities())) {
      if (!isSemanticModelGeneralization(entity)) {
        continue;
      }
      if (entity.child !== identifier) {
        continue;
      }
      // Find the specialized entity.
      const specialized = allSpecializations
        .find(item => item.identifier === entity.parent);
      result.push({
        iri: entity.iri ?? "",
        specializationOf: {
          identifier: specialized?.identifier ?? entity.parent,
          model: specialized?.model ?? UNDEFINED_MODEL,
        },
        generalization: {
          identifier: entity.id,
          model: model.getId(),
        },
      });
    }
  }
  return result;
}
